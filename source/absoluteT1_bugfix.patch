diff --git a/source/lib/PccLibCommon/include/PCCCodec.h b/source/lib/PccLibCommon/include/PCCCodec.h
index a590610..5296ba8 100644
--- a/source/lib/PccLibCommon/include/PCCCodec.h
+++ b/source/lib/PccLibCommon/include/PCCCodec.h
@@ -74,6 +74,9 @@ struct GeneratePointCloudParameters {
   size_t      nbThread_;
   bool        multipleStreams_;
   bool        absoluteD1_;
+  #if BUGFIX
+  bool        absoluteT1_;
+  #endif
   size_t      surfaceThickness_;
   double      thresholdColorSmoothing_;
   bool        gridColorSmoothing_;
diff --git a/source/lib/PccLibCommon/include/PCCCommon.h b/source/lib/PccLibCommon/include/PCCCommon.h
index f924e87..a949329 100755
--- a/source/lib/PccLibCommon/include/PCCCommon.h
+++ b/source/lib/PccLibCommon/include/PCCCommon.h
@@ -65,6 +65,11 @@
 #include "PCCChrono.h"
 #endif
 
+#define OUTPUTFIX 1
+
+#define BUGFIX 1
+#define DELTA_VALUE_LOSSLESS 1
+#define RAWOCCMAPFIX 1
 namespace pcc {
 
 // ******************************************************************* //
diff --git a/source/lib/PccLibCommon/source/PCCCodec.cpp b/source/lib/PccLibCommon/source/PCCCodec.cpp
index 8964c08..424622a 100755
--- a/source/lib/PccLibCommon/source/PCCCodec.cpp
+++ b/source/lib/PccLibCommon/source/PCCCodec.cpp
@@ -1813,6 +1813,7 @@ bool PCCCodec::colorPointCloud( PCCPointSet3&                       reconstruct,
             // reconstruction
             int16_t value0 = static_cast<int16_t>( image0.getValue( c, x, y ) );
             int16_t value1 = static_cast<int16_t>( image1.getValue( c, x, y ) );
+//BUGFIX
             if ( !absoluteT1List[f] ) {
               int16_t delta = value1;
               delta         = delta - 128;
diff --git a/source/lib/PccLibDecoder/source/PCCBitstreamDecoder.cpp b/source/lib/PccLibDecoder/source/PCCBitstreamDecoder.cpp
index 6871599..eb0ee2d 100644
--- a/source/lib/PccLibDecoder/source/PCCBitstreamDecoder.cpp
+++ b/source/lib/PccLibDecoder/source/PCCBitstreamDecoder.cpp
@@ -192,7 +192,12 @@ void PCCBitstreamDecoder::vpccUnit( PCCContext& context, VpccUnit& currVpccUnit,
   vpccUnitHeader( context, bitstream, vpccUnitType );
   assert( vpccUnitType == currVpccUnit.getVpccUnitType() );
   vpccUnitPayload( context, bitstream, vpccUnitType );
+#if OUTPUTFIX
+  int32_t position2 = (int32_t)bitstream.size() - position;
+  context.getBitstreamStat().setVpccUnitSize( vpccUnitType, context.getBitstreamStat().getVpccUnitSize( vpccUnitType)+position2);
+#else
   context.getBitstreamStat().setVpccUnitSize( vpccUnitType, (int32_t)bitstream.size() - position );
+#endif
   TRACE_BITSTREAM( "vpccUnit: vpccUnitType = %d(%s) \n", vpccUnitType, toString( vpccUnitType ).c_str() );
   TRACE_BITSTREAM( "vpccUnit: size [%d ~ %d] \n", position, bitstream.size() );
   TRACE_BITSTREAM( "%s done\n", __func__ );
@@ -372,7 +377,12 @@ void PCCBitstreamDecoder::attributeInformation( AttributeInformation& ai,
       ai.setRawAttributeCodecId( i, bitstream.read( 8 ) );  // u(8)
     }
     ai.addAttributeMapAbsoluteCodingEnabledFlag( i, true );
-    for ( int32_t j = 0; j < sps.getMapCountMinus1( atlasIndex ); j++ ) {
+#if BUGFIX
+    for ( int32_t j = 1; j < sps.getMapCountMinus1( atlasIndex )+1; j++ )
+#else
+    for ( int32_t j = 0; j < sps.getMapCountMinus1( atlasIndex ); j++ )
+#endif
+    {
       if ( sps.getMapAbsoluteCodingEnableFlag( atlasIndex, j ) == 0 ) {
         ai.addAttributeMapAbsoluteCodingEnabledFlag( i, bitstream.read( 1 ) );  // u(1)
       } else {
diff --git a/source/lib/PccLibEncoder/include/PCCEncoder.h b/source/lib/PccLibEncoder/include/PCCEncoder.h
index 4e7ec77..22934fe 100755
--- a/source/lib/PccLibEncoder/include/PCCEncoder.h
+++ b/source/lib/PccLibEncoder/include/PCCEncoder.h
@@ -144,7 +144,10 @@ class PCCEncoder : public PCCCodec {
                            std::vector<uint32_t>& occupancyMap,
                            PCCImageOccupancyMap&  videoFrameOccupancyMap,
                            std::ofstream&         ofile );
-
+#if RAWOCCMAPFIX
+  void markRawPatchLocationOccupancyMapVideo(PCCContext& context);
+  void markRawPatchLocation(PCCFrameContext& contextFrame, PCCImageOccupancyMap&   occupancyMap);
+#endif
   bool generateGeometryVideo( const PCCGroupOfFrames& sources, PCCContext& context );
   bool resizeGeometryVideo( PCCContext& context );
   bool dilateGeometryVideo( const PCCGroupOfFrames& sources, PCCContext& context );
diff --git a/source/lib/PccLibEncoder/include/PCCPatchSegmenter.h b/source/lib/PccLibEncoder/include/PCCPatchSegmenter.h
index d75117f..f67b07b 100755
--- a/source/lib/PccLibEncoder/include/PCCPatchSegmenter.h
+++ b/source/lib/PccLibEncoder/include/PCCPatchSegmenter.h
@@ -131,7 +131,9 @@ class PCCPatchSegmenter3 {
                                      std::vector<std::vector<size_t>>& adj,
                                      const size_t                      maxNNCount,
                                      const size_t                      radius );
-
+#if DELTA_VALUE_LOSSLESS
+  bool colorSimilarity(PCCColor3B& colorD1candidate,PCCColor3B& colorD0, uint8_t threshold);
+#endif
   void segmentPatches( const PCCPointSet3&                 points,
                        const size_t                        frameIndex,
                        const PCCKdTree&                    kdtree,
diff --git a/source/lib/PccLibEncoder/source/PCCBitstreamEncoder.cpp b/source/lib/PccLibEncoder/source/PCCBitstreamEncoder.cpp
index 5c28ea0..fdc7067 100644
--- a/source/lib/PccLibEncoder/source/PCCBitstreamEncoder.cpp
+++ b/source/lib/PccLibEncoder/source/PCCBitstreamEncoder.cpp
@@ -322,7 +322,12 @@ void PCCBitstreamEncoder::vpccUnit( PCCContext& context, PCCBitstream& bitstream
   int32_t position = (int32_t)bitstream.size();
   vpccUnitHeader( context, bitstream, vpccUnitType );
   vpccUnitPayload( context, bitstream, vpccUnitType );
+#if OUTPUTFIX
+  int32_t position2 = (int32_t)bitstream.size() - position;
+  context.getBitstreamStat().setVpccUnitSize( vpccUnitType, context.getBitstreamStat().getVpccUnitSize( vpccUnitType)+position2);
+#else
   context.getBitstreamStat().setVpccUnitSize( vpccUnitType, (int32_t)bitstream.size() - position );
+#endif
   TRACE_BITSTREAM( "vpccUnit: vpccUnitType = %d(%s) \n", vpccUnitType, toString( vpccUnitType ).c_str() );
   TRACE_BITSTREAM( "vpccUnit: size [%d ~ %d] \n", position, bitstream.size() );
   TRACE_BITSTREAM( "%s done\n", __func__ );
@@ -486,7 +491,12 @@ void PCCBitstreamEncoder::attributeInformation( AttributeInformation& ai,
       bitstream.write( (uint32_t)ai.getRawAttributeCodecId( i ), 8 );  // u(8)
     }
     for ( int32_t j = 0; j < sps.getMapCountMinus1( atlasIndex ); j++ ) {
-      if ( sps.getMapAbsoluteCodingEnableFlag( atlasIndex, j ) == 0 ) {
+#if BUGFIX
+      if ( sps.getMapAbsoluteCodingEnableFlag( atlasIndex, j + 1 ) == 0 )
+#else
+      if ( sps.getMapAbsoluteCodingEnableFlag( atlasIndex, j ) == 0 )
+#endif
+      {
         bitstream.write( (uint32_t)ai.getAttributeMapAbsoluteCodingEnabledFlag( i, j + 1 ), 1 );  // u(1)
       }
     }
diff --git a/source/lib/PccLibEncoder/source/PCCEncoder.cpp b/source/lib/PccLibEncoder/source/PCCEncoder.cpp
index 93b3579..85427a2 100644
--- a/source/lib/PccLibEncoder/source/PCCEncoder.cpp
+++ b/source/lib/PccLibEncoder/source/PCCEncoder.cpp
@@ -196,7 +196,11 @@ int PCCEncoder::encode( const PCCGroupOfFrames& sources, PCCContext& context, PC
     std::cout << "Percentage of changed occupancy map values from 1 to 0 = "
               << ( (float)changedPixCnt1To0 * 100.0F / pixCnt ) << std::endl;
   }
-
+#if 0 //RAWOCCMAPFIX :jkei - better here??
+  if(!params_.useMissedPointsSeparateVideo_ && (params_.losslessGeo_ || params_.lossyMissedPointsPatch_)){
+    markRawPatchLocationOccupancyMapVideo(context);
+  }
+#endif
   generateBlockToPatchFromOccupancyMapVideo( context, params_.losslessGeo_, params_.lossyMissedPointsPatch_,
                                              params_.occupancyResolution_, params_.occupancyPrecision_ );
 
@@ -3522,7 +3526,7 @@ void PCCEncoder::generateOccupancyMap( PCCFrameContext& frame ) {
       }
     }
   }
-
+#if !RAWOCCMAPFIX
   if ( !frame.getUseMissedPointsSeparateVideo() ) {
     size_t numberOfMpsPatches = frame.getNumberOfMissedPointsPatches();
     for ( int i = 0; i < numberOfMpsPatches; i++ ) {
@@ -3550,6 +3554,7 @@ void PCCEncoder::generateOccupancyMap( PCCFrameContext& frame ) {
       }
     }
   }
+#endif
   if ( !params_.absoluteD1_ || !params_.absoluteT1_ ) { fullOccupancyMap = occupancyMap; }
 }
 
@@ -4687,7 +4692,55 @@ bool PCCEncoder::resizeGeometryVideo( PCCContext& context ) {
   }
   return true;
 }
+#if RAWOCCMAPFIX
+void PCCEncoder::markRawPatchLocationOccupancyMapVideo(PCCContext& context)
+{
+  auto& videoOccupancyMap = context.getVideoOccupancyMap();
+  for(size_t f=0; f<context.size(); f++){
+    markRawPatchLocation(context[f], videoOccupancyMap.getFrame( f ));
+  }
+}
 
+void PCCEncoder::markRawPatchLocation(//const PCCContext& context, size_t frameIndex,
+                                      PCCFrameContext& contextFrame,
+                                      PCCImageOccupancyMap&   occupancyMap)
+{
+  //auto& contetFrame = context[frameIndex];
+  if ( !contextFrame.getUseMissedPointsSeparateVideo() ) {
+    //for padding purpose
+    size_t width = occupancyMap.getWidth();
+    size_t height = occupancyMap.getHeight();
+    
+    size_t numberOfMpsPatches = contextFrame.getNumberOfMissedPointsPatches();
+    for ( int i = 0; i < numberOfMpsPatches; i++ ) {
+      auto&        missedPointsPatch = contextFrame.getMissedPointsPatch( i );
+      const size_t v0                = missedPointsPatch.v0_ * missedPointsPatch.occupancyResolution_;
+      const size_t u0                = missedPointsPatch.u0_ * missedPointsPatch.occupancyResolution_;
+      if ( missedPointsPatch.size() ) {
+        for ( size_t v = 0; v < missedPointsPatch.sizeV_; ++v ) {
+          for ( size_t u = 0; u < missedPointsPatch.sizeU_; ++u ) {
+            const size_t p = v * missedPointsPatch.sizeU_ + u;
+            if ( missedPointsPatch.x_[p] < infiniteDepth ) {
+              // if (p < missedPointsPatch.getNumberOfMps()) {
+              const size_t x = ( u0 + u );
+              const size_t y = ( v0 + v );
+              if ( x >= width || y >= height ) {
+                std::cout << "\t\tout of image :" << x << "," << y << "(" << x + y * width << ") vs occupancyMap size :"
+                << width <<"x"<<height << std::endl;
+                exit( 0 );
+              }
+              assert( x < width && y < height );
+              occupancyMap.setValue(0, x, y, 1);
+              contextFrame.getOccupancyMap()[x + y * width] = 1;
+              //auto&                 occupancyMapOriginal =
+            }
+          }
+        }
+      }
+    }
+  }
+}
+#endif
 bool PCCEncoder::dilateGeometryVideo( const PCCGroupOfFrames& sources, PCCContext& context ) {
   auto& videoGeometry     = context.getVideoGeometry();
   auto& videoGeometryD1   = context.getVideoGeometryD1();
@@ -4921,6 +4974,11 @@ void PCCEncoder::dilate3DPadding( const PCCPointSet3&     source,
                                    PCCImageGeometry&       image,
                                    PCCImageOccupancyMap&   occupancyMap,
                                    const PCCImageGeometry* reference ) {
+#if RAWOCCMAPFIX
+  if(!params_.useMissedPointsSeparateVideo_ && (params_.losslessGeo_ || params_.lossyMissedPointsPatch_)){
+    markRawPatchLocation(frame, occupancyMap);
+  }
+#endif
   const size_t  pixelBlockCount          = params_.occupancyResolution_ * params_.occupancyResolution_;
   const size_t  occupancyMapSizeU        = image.getWidth() / params_.occupancyResolution_;
   const size_t  occupancyMapSizeV        = image.getHeight() / params_.occupancyResolution_;
@@ -4952,6 +5010,8 @@ void PCCEncoder::dilate3DPadding( const PCCPointSet3&     source,
             }
           }
         }
+        assert(count>0);
+        if(count==0) exit(-1);
         mean_val /= count;
         // now fill in the missing positions with depth values searched in 3D space
         for ( size_t j = 0; j < params_.occupancyPrecision_; j++ ) {
@@ -7007,6 +7067,9 @@ void PCCEncoder::setGeneratePointCloudParameters( GeneratePointCloudParameters&
   params.rawPointColorFormat_           = size_t( params_.losslessGeo444_ ? COLOURFORMAT444 : COLOURFORMAT420 );
   params.nbThread_                      = params_.nbThread_;
   params.absoluteD1_                    = params_.absoluteD1_;
+#if BUGFIX
+  params.absoluteT1_ = params_.absoluteT1_;
+#endif
   params.multipleStreams_               = params_.mapCountMinus1_ == 0 || params_.multipleStreams_;
   params.surfaceThickness_              = params_.surfaceThickness_;
   params.thresholdColorSmoothing_       = params_.thresholdColorSmoothing_;
diff --git a/source/lib/PccLibEncoder/source/PCCEncoderParameters.cpp b/source/lib/PccLibEncoder/source/PCCEncoderParameters.cpp
index c890147..0f44727 100755
--- a/source/lib/PccLibEncoder/source/PCCEncoderParameters.cpp
+++ b/source/lib/PccLibEncoder/source/PCCEncoderParameters.cpp
@@ -782,10 +782,14 @@ void PCCEncoderParameters::initializeContext( PCCContext& context ) {
     ai.setAttributeNominal2dBitdepthMinus1( 0, 7 );
     ai.setAttributeMSBAlignFlag( false );
   }
-
   for ( size_t i = 0; i < ai.getAttributeCount(); i++ ) {
-    ai.addAttributeMapAbsoluteCodingEnabledFlag( i, true );  // first map
-    for ( size_t j = 0; j < sps.getMapCountMinus1( ATLASIDXPCC ); j++ ) {
+ #if BUGFIX
+    for ( size_t j = 0; j <= sps.getMapCountMinus1( ATLASIDXPCC ); j++ )
+#else
+      ai.addAttributeMapAbsoluteCodingEnabledFlag( i, true );  // first map
+    for ( size_t j = 0; j < sps.getMapCountMinus1( ATLASIDXPCC ); j++ )
+#endif
+    {
       if ( sps.getMapAbsoluteCodingEnableFlag( ATLASIDXPCC, j ) == 0 ) {
         ai.addAttributeMapAbsoluteCodingEnabledFlag( i, (bool)absoluteT1_ );
       } else {
diff --git a/source/lib/PccLibEncoder/source/PCCPatchSegmenter.cpp b/source/lib/PccLibEncoder/source/PCCPatchSegmenter.cpp
index a47b115..e4b1037 100755
--- a/source/lib/PccLibEncoder/source/PCCPatchSegmenter.cpp
+++ b/source/lib/PccLibEncoder/source/PCCPatchSegmenter.cpp
@@ -238,6 +238,15 @@ void printChunk( const std::vector<std::pair<int, int>>& chunk ) {
   std::cout << std::endl;
 }
 
+#if DELTA_VALUE_LOSSLESS
+bool PCCPatchSegmenter3::colorSimilarity(PCCColor3B& colorD1candidate,PCCColor3B& colorD0, uint8_t threshold){
+  bool bSimilarity    = ( std::abs( colorD0[0] - colorD1candidate[0] ) < threshold ) &&
+                     ( std::abs( colorD0[1] - colorD1candidate[1] ) < threshold ) &&
+                     ( std::abs( colorD0[2] - colorD1candidate[2] ) < threshold );
+  return bSimilarity;
+}
+#endif
+
 void PCCPatchSegmenter3::segmentPatches( const PCCPointSet3&                 points,
                                          const size_t                        frameIndex,
                                          const PCCKdTree&                    kdtree,
@@ -1135,6 +1144,32 @@ void PCCPatchSegmenter3::segmentPatches( const PCCPointSet3&                 poi
               assert( v >= 0 && v < patch.getSizeV() );
               const size_t  p      = v * patch.getSizeU() + u;
               const int16_t depth0 = patch.getDepth( 0 )[p];
+#if DELTA_VALUE_LOSSLESS
+              bool          validD1          = false;
+              if( !( depth0 < infiniteDepth )) continue;
+              bool bsimilar = colorSimilarity( frame_pcc_color[i], frame_pcc_color[patch.getDepth0PccIdx()[p]], 128);
+              validD1 = depth0 < infiniteDepth && ( d - depth0 ) <= int16_t( surfaceThickness ) && d > patch.getDepth( 1 )[p] && bsimilar;
+              if (validD1) {
+                patch.getDepth( 1 )[p] = d;
+              }
+              if ( useEnhancedDeltaDepthCode && depth0 < infiniteDepth && ( d - depth0 ) > 0 &&
+                   ( d - depth0 ) <= int16_t( surfaceThickness ) && bsimilar ) {
+                const uint16_t oldEDDCode = patch.getDepthEnhancedDeltaD()[p];
+                const uint16_t deltaD     = d - depth0;
+                int            comp_depth0;
+
+                comp_depth0 = depth0 - patch.getD1();
+
+                patch.getDepthEnhancedDeltaD()[p] |= 1 << ( deltaD - 1 );
+                if ( ( comp_depth0 + patch.getDepthEnhancedDeltaD()[p] ) > maxD ) {
+                  patch.getDepthEnhancedDeltaD()[p] = oldEDDCode;
+                  std::cout
+                      << "(D0 + EDD-Code) > maxD. Data overflow observed (assume using 10bit coding). Temporary "
+                         "solution: the corresponding inbetween or Depth1 point will be regarded as missing point. "
+                         "To be improved if this happens a lot...\n";
+                }
+              }
+#else
               if ( depth0 < infiniteDepth && ( d - depth0 ) <= int16_t( surfaceThickness ) &&
                    d > patch.getDepth( 1 )[p] ) {
                 patch.getDepth( 1 )[p] = d;
@@ -1156,6 +1191,7 @@ void PCCPatchSegmenter3::segmentPatches( const PCCPointSet3&                 poi
                          "To be improved if this happens a lot...\n";
                 }
               }
+#endif
               if ( patch.getDepth( 1 )[p] < patch.getDepth( 0 )[p] ) {
                 std::cout << "1.compute d1 map : ERROR : proj0 and d1 < d0" << std::endl;
               }
@@ -1186,9 +1222,21 @@ void PCCPatchSegmenter3::segmentPatches( const PCCPointSet3&                 poi
                 const size_t  p      = v * patch.getSizeU() + u;
                 const int16_t depth0 = patch.getDepth( 0 )[p];
                 tot_num++;
+#if DELTA_VALUE_LOSSLESS
+                if( !( depth0 < infiniteDepth )) continue;
+                bool          validD1          = false;
+                if( !( depth0 < infiniteDepth )) continue;
+                bool bsimilar = colorSimilarity( frame_pcc_color[i], frame_pcc_color[patch.getDepth0PccIdx()[p]], 128);
+#endif
                 if ( err_flag == false ) {
+#if DELTA_VALUE_LOSSLESS
+                  validD1 = ( depth0 < infiniteDepth && ( d - depth0 ) <= int16_t( patch_surfaceThickness ) && d > patch.getDepth( 1 )[p] ) && bsimilar;
+                  if(validD1)
+#else
                   if ( depth0 < infiniteDepth && ( d - depth0 ) <= int16_t( patch_surfaceThickness ) &&
-                       d > patch.getDepth( 1 )[p] ) {
+                       d > patch.getDepth( 1 )[p] )
+#endif
+                  {
                     d1_num++;
                     const size_t     d0_idx   = patch.getDepth0PccIdx()[p];
                     const size_t     d1_idx   = i;
@@ -1212,12 +1260,26 @@ void PCCPatchSegmenter3::segmentPatches( const PCCPointSet3&                 poi
                     err_sum += delta_e;
                   }
                 } else {
+#if DELTA_VALUE_LOSSLESS
+                  validD1 = ( depth0 < infiniteDepth && ( d - depth0 ) <= int16_t( patch_surfaceThickness ) &&
+                  d > patch.getDepth( 1 )[p] ) && bsimilar;
+                  if(validD1)
+#else
                   if ( depth0 < infiniteDepth && ( d - depth0 ) <= int16_t( patch_surfaceThickness ) &&
-                       d > patch.getDepth( 1 )[p] ) {
+                       d > patch.getDepth( 1 )[p] )
+#endif
+                  {
                     patch.getDepth( 1 )[p] = d;
                   }
+#if DELTA_VALUE_LOSSLESS
                   if ( useEnhancedDeltaDepthCode && depth0 < infiniteDepth && ( d - depth0 ) > 0 &&
-                       ( d - depth0 ) <= int16_t( surfaceThickness ) ) {
+                       ( d - depth0 ) <= int16_t( surfaceThickness ) && bsimilar )
+#else
+                    if ( useEnhancedDeltaDepthCode && depth0 < infiniteDepth && ( d - depth0 ) > 0 &&
+                        ( d - depth0 ) <= int16_t( surfaceThickness ) )
+#endif
+                    
+                  {
                     const uint16_t oldEDDCode = patch.getDepthEnhancedDeltaD()[p];
                     const uint16_t deltaD     = d - depth0;
                     int            comp_depth0;
@@ -1268,21 +1330,33 @@ void PCCPatchSegmenter3::segmentPatches( const PCCPointSet3&                 poi
               assert( v >= 0 && v < patch.getSizeV() );
               const size_t  p                = v * patch.getSizeU() + u;
               const int16_t depth0           = patch.getDepth( 0 )[p];
+#if DELTA_VALUE_LOSSLESS
               bool          validD1          = false;
-              bool          bColorDifference = true;
-              PCCColor3B    colorD1candidate;
-              PCCColor3B    colorD0;
-              if ( depth0 < infiniteDepth ) {
-                const size_t d0_idx = patch.getDepth0PccIdx()[p];
-                const size_t d1_idx = i;
-                colorD1candidate    = frame_pcc_color[d1_idx];
-                colorD0             = frame_pcc_color[d0_idx];
-                bColorDifference    = ( std::abs( colorD0[0] - colorD1candidate[0] ) < 128 ) &&
-                                   ( std::abs( colorD0[1] - colorD1candidate[1] ) < 128 ) &&
-                                   ( std::abs( colorD0[2] - colorD1candidate[2] ) < 128 );
-                validD1 = depth0 < infiniteDepth && ( depth0 - d ) <= int16_t( surfaceThickness ) &&
-                          d < patch.getDepth( 1 )[p] && bColorDifference;
+              if( !( depth0 < infiniteDepth )) continue;
+              bool bsimilar = colorSimilarity( frame_pcc_color[i], frame_pcc_color[patch.getDepth0PccIdx()[p]], 128);
+              validD1 = depth0 < infiniteDepth && ( depth0 - d ) <= int16_t( surfaceThickness ) &&
+              d < patch.getDepth( 1 )[p] && bsimilar;
+              if(validD1){
+                patch.getDepth( 1 )[p] = d;
+              }
+              if ( useEnhancedDeltaDepthCode && depth0 < infiniteDepth && ( depth0 - d ) > 0 &&
+                   ( depth0 - d ) <= int16_t( surfaceThickness ) && bsimilar ) { //bsimilar
+                const uint16_t oldEDDCode = patch.getDepthEnhancedDeltaD()[p];
+                const uint16_t deltaD     = depth0 - d;
+                int            comp_depth0;
+
+                comp_depth0 = patch.getD1() - depth0;
+
+                patch.getDepthEnhancedDeltaD()[p] |= 1 << ( deltaD - 1 );
+                if ( ( comp_depth0 + patch.getDepthEnhancedDeltaD()[p] ) > 1023 ) {
+                  patch.getDepthEnhancedDeltaD()[p] = oldEDDCode;
+                  std::cout
+                      << "(D0 + EDD-Code) > 1023. Data overflow observed (assume using 10bit coding). Temporary "
+                         "solution: the corresponding inbetween or Depth1 point will be regarded as missing point. "
+                         "To be improved if this happens a lot...\n";
+                }
               }
+#else
               if ( depth0 < infiniteDepth && ( depth0 - d ) <= int16_t( surfaceThickness ) &&
                    d < patch.getDepth( 1 )[p] ) {
                 patch.getDepth( 1 )[p] = d;
@@ -1304,7 +1378,8 @@ void PCCPatchSegmenter3::segmentPatches( const PCCPointSet3&                 poi
                          "To be improved if this happens a lot...\n";
                 }
               }
-            }
+#endif
+            } //i
           } else {  // Surface Separation
             bool   proc_d1_select_flag    = true;
             bool   err_flag               = false;
@@ -1332,9 +1407,21 @@ void PCCPatchSegmenter3::segmentPatches( const PCCPointSet3&                 poi
                 const size_t  p      = v * patch.getSizeU() + u;
                 const int16_t depth0 = patch.getDepth( 0 )[p];
                 tot_num++;
+#if DELTA_VALUE_LOSSLESS
+                bool          validD1          = false;
+                if( !( depth0 < infiniteDepth )) continue;
+                bool bsimilar = colorSimilarity( frame_pcc_color[i], frame_pcc_color[patch.getDepth0PccIdx()[p]], 128);
+#endif
                 if ( err_flag == false ) {
+#if DELTA_VALUE_LOSSLESS
+                  validD1 = depth0 < infiniteDepth && ( depth0 - d ) <= int16_t( surfaceThickness ) &&
+                  d < patch.getDepth( 1 )[p] && bsimilar;
+                  if(validD1)
+#else
                   if ( depth0 < infiniteDepth && ( depth0 - d ) <= int16_t( patch_surfaceThickness ) &&
-                       d < patch.getDepth( 1 )[p] ) {
+                       d < patch.getDepth( 1 )[p] )
+#endif
+                  {
                     d1_num++;
                     const size_t     d0_idx   = patch.getDepth0PccIdx()[p];
                     const size_t     d1_idx   = i;
@@ -1347,14 +1434,29 @@ void PCCPatchSegmenter3::segmentPatches( const PCCPointSet3&                 poi
                     err_sum += delta_e;
                   }
                 } else {
+#if DELTA_VALUE_LOSSLESS
+                  validD1 =( depth0 < infiniteDepth &&
+                       ( depth0 - d ) <= int16_t( patch_surfaceThickness )  // fixed to patch_surfaceThickness
+                       && d < patch.getDepth( 1 )[p]                        // case 2
+                  ) && bsimilar;
+                  if(validD1)
+#else
                   if ( depth0 < infiniteDepth &&
                        ( depth0 - d ) <= int16_t( patch_surfaceThickness )  // fixed to patch_surfaceThickness
                        && d < patch.getDepth( 1 )[p]                        // case 2
-                  ) {
+                  )
+#endif
+                  {
                     patch.getDepth( 1 )[p] = d;
                   }
+#if DELTA_VALUE_LOSSLESS
+                  if( useEnhancedDeltaDepthCode && depth0 < infiniteDepth && ( depth0 - d ) > 0 &&
+                  ( depth0 - d ) <= int16_t( surfaceThickness ) && bsimilar)
+#else
                   if ( useEnhancedDeltaDepthCode && depth0 < infiniteDepth && ( depth0 - d ) > 0 &&
-                       ( depth0 - d ) <= int16_t( surfaceThickness ) ) {
+                       ( depth0 - d ) <= int16_t( surfaceThickness ) )
+#endif
+                  {
                     const uint16_t oldEDDCode = patch.getDepthEnhancedDeltaD()[p];
                     const uint16_t deltaD     = depth0 - d;
                     int            comp_depth0;
